
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]

/**
 *  tsp-sol - an experimental environment for traveling salesman solution analysis
 *  Copyright (C) 2019  Jeffrey McAteer <jeffrey.p.mcateer@gmail.com>
 *  
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; version 2 of the License ONLY.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

use tsplib::{NodeCoord};

use image::{RgbImage, Rgb, GenericImage};

use imageproc::drawing::*;

use rusttype::{Font, Scale};

use rand::prelude::*;

use permutohedron;

use threadpool::ThreadPool;
use num_cpus;

use once_cell::sync::Lazy;

use std::fs;
use std::fs::{File,create_dir};
use std::path::Path;
use std::io::{BufReader};
use std::sync::{Mutex};
use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::env;
//use std::io::prelude::*;
use std::f32;
use std::f64;

mod brute_algo;
mod jeff_algo;

#[allow(non_camel_case_types)]
pub type fp = f32;
//pub type fp = f64;

// fp numbers within this distance are considered equal
#[allow(non_upper_case_globals)]
const fp_epsilon: fp = 0.0001;


fn usage() {
  println!(r#"Usage: ./tsp-sol path/to/berlin52.tsp|delta|selective|spray

Passing a single file (tsp/berlin52.tsp) will run JeffAlgo on it and pring the size and solution path.

delta will cause 1000 runs using both JeffAlgo and BruteAlgo, incorrect JeffAlgo runs will be dumped to the ./views directory.

selective loops throuh increasingly large cities and exits when JeffAlgo does not match BruteAlgo.

spray requires 2 numbers after it, the N-1 size of the city and a resolution to spray over. `spray` also takes
      the initial N-1 city coordinates from the environment variable TSP_INITIAL_COORDS. An example
      is TSP_INITIAL_COORDS='2.5,8.5 7.5,8.5 12.5,8.5 7.5,9.0' ./tsp-sol spray 4 0.2.
      This creates a city with the above coordinates, then for every point 0.2 units apart in
      the bounding box it attempts to insert it using both JeffAlgo and BruteAlgo. If the tours
      generated by JeffAlgo and BruteAlgo match a green pixel will be plotted on ./views/spray.png,
      if they do not match a red pixel is plotted. This may be used to graphically show where
      JeffAlgo fails to uphold the hamiltonian cycle invariant from city size N to N+1.

  pattern-scan N granularity

"#);
}

/// We will read in a problem & compute a weights matrix, the solver must return
/// a vector of the path to take from city index to index.
/// Solver function header:
///   pub fn solve(node_coordinates: Vec<(usize, fp, fp)>, weights: &Vec<Vec<fp>>) -> Vec<usize>

fn main() {
  let begin_time = std::time::Instant::now();
  timed_main();
  let exec_duration = begin_time.elapsed();
  println!("=== Elapsed time: {:?} ===", exec_duration);
  
  // Flush any brute algo cache we may have
  if let Err(e) = brute_algo::PICKLE_DB.get_mut().dump() {
    eprintln!("Error saving brute cache: {:?}", e);
  }
  if let Err(e) = brute_algo::MULTI_PICKLE_DB.get_mut().dump() {
    eprintln!("Error saving multi brute cache: {:?}", e);
  }

}

fn timed_main() {
  let args: Vec<_> = env::args().collect();
  if args.len() < 2 {
    usage();
    return;
  }
  
  if cfg!(windows) {
    attempt_to_raise_priority();
  }
  
  let thread_pool = ThreadPool::new( num_cpus::get_physical() );
  println!("Brute force algo thread pool size: {}", thread_pool.max_count());
  
  let file_arg = args.get(1).unwrap();

  let mut use_jalgo = true;
  let mut use_brute = false;
  let mut write_solution_out_to_views = false;
  for arg in &args {
    if arg == "jalgo" {
      println!("Enabling jalgo...");
      use_jalgo = true;
    }
    if arg == "brute" {
      println!("Enabling brute...");
      use_brute = true;
    }
    if arg == "no-jalgo" {
      println!("Disabling jalgo...");
      use_jalgo = false;
    }
    if arg == "no-brute" {
      println!("Brute jalgo...");
      use_brute = false;
    }
    if arg == "view" {
      write_solution_out_to_views = true;
    }
    if arg == "no-view" {
      write_solution_out_to_views = false;
    }
  }

  if file_arg == "pattern-scan" {
    // Given a city of points, add one more in a grid and
    // store a color based on the optimal point arrangement.
    // Sections w/ the same ideal solution path will be grouped
    // as the same color.
    pattern_scan(
      args.get(2).unwrap_or(&"5".to_string()).parse().unwrap(), // given number OR 5
      args.get(3).unwrap_or(&"0.25".to_string()).parse().unwrap(), // given number OR 0.25
      "views/pattern-scan.png",
      &thread_pool
    );
    return;
  }

  if file_arg == "multi-pattern-scan" {
    // Same as pattern-scan, but take in 2 cities and perform
    // pattern_scan in steps 
    multi_pattern_scan(
      args.get(2).unwrap_or(&"5".to_string()).parse().unwrap(), // given number OR 5 - number of cities
      args.get(3).unwrap_or(&"0.25".to_string()).parse().unwrap(), // given number OR 0.25 - resolution to generate a SINGLE multi pattern at
      args.get(4).unwrap_or(&"10".to_string()).parse().unwrap(), // number of steps to put between 2 cities, aka total number of pattern_scans to run.
      &thread_pool
    );
    return;
  }
  
  if file_arg == "delta" {
    let num = 1000;
    let num_failed = delta(num, 4, 8, &thread_pool); // test the algorithm on a thousand generated cities, between 4-8 points each.
    println!("Failed {} out of {}", num_failed, num);
    return;
  }
  
  if file_arg == "selective" {
    // generate increasing city size until failure (jeff() != brute()), then go back and map a large range of points
    let max_cities_to_test: usize = args.get(2).unwrap_or(&"11".to_string()).parse().unwrap();  // arg after "selective" OR 11
    let num_to_test_before: usize = args.get(3).unwrap_or(&"2".to_string()).parse().unwrap();  // arg after "max_cities_to_test" OR 1
    let mut min_cities_to_ignore = max_cities_to_test - num_to_test_before;
    if min_cities_to_ignore >= max_cities_to_test {
      println!("Invalid num_to_test_before passed ({}), resetting min_cities_to_ignore from {} to {}", num_to_test_before, min_cities_to_ignore, max_cities_to_test - 1);
      min_cities_to_ignore = max_cities_to_test - 1;
    }
    selective(
      min_cities_to_ignore,
      max_cities_to_test,
      &thread_pool
    );
    return;
  }
  
  if file_arg == "spray" {
    // Generate random N points then add a grid of points and track where insertion
    // results in a non-optimal path.
    spray(
      args.get(2).unwrap_or(&"5".to_string()).parse().unwrap(), // given number OR 5
      args.get(3).unwrap_or(&"0.25".to_string()).parse().unwrap(), // given number OR 0.25
      &thread_pool
    );
    return;
  }

  let (node_coordinates, weights) = match open_tsp_problem(file_arg.to_string()) {
    Some(stuff) => stuff,
    None => {
      return; // error message printed in open_tsp_problem
    }
  };

  // First dump the environment variable we'd need to set to scan this city,
  // useful for going from .tsp file -> research
  let mut env_s = "TSP_INITIAL_COORDS='".to_string();
  for (_i, x, y) in node_coordinates.iter() {
    env_s += format!("{:.2},{:.2} ", x, y).as_str();
  }
  env_s += "'";
  println!("{}", env_s);
  
  if use_jalgo {
    let solution_p = if write_solution_out_to_views {
      jeff_algo::solve(&node_coordinates, &weights, Some( "./views/tsp_problem".to_string() ))
    }
    else {
      jeff_algo::solve(&node_coordinates, &weights, None)
    };
    println!("====== jeff_algo::solve ======");
    print_path_metadata(&solution_p, &weights);
  }
  
  if use_brute {
    let solution_p = if write_solution_out_to_views {
      brute_algo::solve_all(&node_coordinates, &weights, Some( "./views/tsp_problem".to_string() ), &thread_pool)[0]
    }
    else {
      brute_algo::solve(&node_coordinates, &weights, None, &thread_pool)
    };
    println!("====== brute_algo::solve ======");
    print_path_metadata(&solution_p, &weights);
  }

}

fn attempt_to_raise_priority() {
  use std::process;
  use std::process::{Command, Stdio};
  let our_pid = process::id();
  let psutil_script = if cfg!(windows) {
    //format!("import psutil ; pid={our_pid} ; p=psutil.Process(pid) ; p.cpu_affinity([0]) ; p.nice(psutil.HIGH_PRIORITY_CLASS)", our_pid=our_pid)
    //format!("import psutil ; pid={our_pid} ; p=psutil.Process(pid) ; p.nice(psutil.HIGH_PRIORITY_CLASS)", our_pid=our_pid)
    format!("import psutil ; pid={our_pid} ; p=psutil.Process(pid) ; p.nice(psutil.HIGH_PRIORITY_CLASS) ; p.cpu_affinity([x for x in range(0, psutil.cpu_count(logical=True)) if x % int(psutil.cpu_count(logical=True) / psutil.cpu_count(logical=False)) == 0 ])", our_pid=our_pid)
  }
  else {
    //format!("import psutil ; pid={our_pid} ; p=psutil.Process(pid) ; p.cpu_affinity([0]) ; p.nice(-5)", our_pid=our_pid)
    format!("import psutil ; pid={our_pid} ; p=psutil.Process(pid) ;  p.nice(-5)", our_pid=our_pid)
  };
  let res = Command::new("python").args(&[
    "-c", &psutil_script
  ])
    .stdout(Stdio::null())
    .stderr(Stdio::null())
    .stdin(Stdio::null())
    .spawn();
}

fn delta(num_tests: usize, lower_city_size: usize, upper_city_size: usize, thread_pool: &ThreadPool) -> usize {
  let mut rng = thread_rng();
  let mut total_failed: usize = 0;
  for i in 0..num_tests {
    let city_size = rng.gen_range(lower_city_size, upper_city_size);
    println!("Delta testing {}/{}", i, num_tests);
    if ! delta_test(city_size, thread_pool) {
      total_failed += 1;
    }
  }
  return total_failed;
}

fn delta_test(city_size: usize, thread_pool: &ThreadPool) -> bool {
  let (node_coordinates, weights) = gen_tsp_problem(city_size, 0.0, 10.0, 0.0, 10.0);
  
  let jeff_sol = jeff_algo::solve(&node_coordinates, &weights, None);
  let brute_sol = brute_algo::solve(&node_coordinates, &weights, None, thread_pool);
  
  let jeff_sol_len = compute_dist(&weights, &jeff_sol);
  let brute_sol_len = compute_dist(&weights, &brute_sol);
  
  let distance_diff = jeff_sol_len - brute_sol_len;
  
  if distance_diff.abs() > fp_epsilon && !is_identical_path(&jeff_sol, &brute_sol) { // account for floating point errors
    // re-do test, saving results
    let r_test_num: usize = rand::thread_rng().gen_range(0, 10000000);
    
    let prefix_dir = format!("./views/{:02}-{}/", weights.len(), r_test_num);
    jeff_algo::solve(&node_coordinates, &weights, Some(prefix_dir.clone()));
    brute_algo::solve_all(&node_coordinates, &weights, Some(prefix_dir.clone()), thread_pool);
    return false;
  }
  return true;
}

fn print_path_metadata(path: &Vec<usize>, weights: &Vec<Vec<fp>>) {
  println!("Solution distance: {}", compute_dist(weights, &path));
  print!("Solution order: ");
  for p in path {
    print!("{} ", *p);
  }
  println!("");
}

// Bounds some number i within len, used heavily in index calculations
fn b(i: usize, len: usize) -> usize {
  return (i + len) % len;
}

fn compute_dist(weights: &Vec<Vec<fp>>, path: &[usize]) -> fp {
  let mut total: fp = 0.0;
  for p_i in 0..path.len() {
    unsafe {
      let p  = path.get_unchecked(  p_i  );
      let p2 = path.get_unchecked(  (p_i+1) % path.len()  ); // mod lets us wrap at end (p_i == len(), (p_i+1) % len == 0)
      total += weights.get_unchecked( *p ).get_unchecked( *p2 );
    }
  }
  return total;
}

fn gen_tsp_problem(num_points: usize, min_x: fp, max_x: fp, min_y: fp, max_y: fp) -> (Vec<(usize, fp, fp)>, Vec<Vec<fp>>) {
  let mut rng = rand::thread_rng();
  let mut node_coordinates: Vec<(usize, fp, fp)> = vec![];
  
  for i in 0..num_points {
    node_coordinates.push(
      (i, rng.gen_range(min_x, max_x), rng.gen_range(min_y, max_y))
    );
  }
  
  // Compute 2x matrix of edge weights (assumes 2d euclidian geometry)
  let mut weights: Vec<Vec<fp>> = Vec::with_capacity(node_coordinates.len());
  {
    for row_r in &node_coordinates {
      let mut row_weight_v: Vec<fp> = Vec::with_capacity(node_coordinates.len());
      for col_r in &node_coordinates {
        let weight: fp = (
          (row_r.1 - col_r.1).powf(2.0) + // x1 + x2 squared
          (row_r.2 - col_r.2).powf(2.0)   // y1 + y2 squared
        ).sqrt();
        
        row_weight_v.push(weight);
      }
      weights.push(row_weight_v);
    }
  }
  
  return (node_coordinates, weights);
}

fn open_tsp_problem(file_arg: String) -> Option<(Vec<(usize, fp, fp)>, Vec<Vec<fp>>)> {
  if ! Path::new(&file_arg).exists() {
    println!("File does not exist: {}", file_arg);
    return None;
  }

  let file = match File::open(file_arg.clone()) {
    Ok(f) => f,
    Err(e) => {
      println!("Cannot open {}: {}", file_arg, e);
      return None;
    }
  };
  
  // Use tsp lib to parse file
  let instance = match tsplib::parse( BufReader::new(file) ) {
    Ok(i) => i,
    Err(e) => {
      println!("Error parsing tsplib file {}: {}", file_arg, e);
      return None;
    }
  };
  
  let node_coordinates: Vec<(usize, f32, f32)> = match instance.node_coord {
    Some(node_c) => match node_c {
      NodeCoord::Two(vec_count_loc_loc) => vec_count_loc_loc,
      NodeCoord::Three(_we_dont_care) => {
        println!("3D TSP problems currently unsupported.");
        return None;
      }
    },
    None => {
      println!("Err: no coordinates found in {}", file_arg);
      return None;
    }
  };
  
  let node_coordinates: Vec<(usize, fp, fp)> = node_coordinates.iter().map(|(a, b, c)| (*a, *b as fp, *c as fp) ).collect();

  // Compute 2x matrix of edge weights (assumes 2d euclidian geometry)
  let weights = compute_weight_coords(&node_coordinates);
  
  println!("City has {} points", weights.len());
  // remember weights is 2d square matrix (could be triangle, meh.)
  
  return Some( (node_coordinates, weights) );
}

// Meh used in imagery

fn compute_center(path: &Vec<usize>, locations: &Vec<(usize, fp, fp)>) -> (fp, fp) {
  let mut x_tot: fp = 0.0;
  let mut y_tot: fp = 0.0;
  
  for p in path {
    x_tot += locations[*p].1;
    y_tot += locations[*p].2;
  }
  
  x_tot /= path.len() as fp;
  y_tot /= path.len() as fp;
  return (x_tot, y_tot);
}

// Shared imagery functions

fn save_state_image<I: Into<String>>(file_path: I, path: &Vec<usize>, locations: &Vec<(usize, fp, fp)>) {
  let file_path = file_path.into();
  let (width, height) = (900, 900);
  let mut image = RgbImage::new(width + 15, height + 15); // width, height

  let (mut smallest_x, mut largest_y, mut largest_x, mut smallest_y) = get_point_extents(locations);

  if smallest_x > 0.0 {
    smallest_x = 0.0;
  }
  if largest_y < 15.0 {
    largest_y = 15.0;
  }
  if largest_x < 15.0 {
    largest_x = 15.0;
  }
  if smallest_y > 0.0 {
    smallest_y = 0.0;
  }
  // we'll expand to a 0x15 grid to normalize most of our data; if something larger comes in
  // the image will merely be skewed between runs by the furthest points

  // smallest_x -= 3.5;
  // largest_y += 3.5;
  // largest_x += 3.5;
  // smallest_y -= 3.5;

  let x_range: fp = largest_x - smallest_x;
  let y_range: fp = largest_y - smallest_y;
  
  let font = Font::try_from_bytes(include_bytes!("../resources/NotoSans-Bold.ttf")).unwrap();

  for i in 0..locations.len() {
    let loc = locations[i];
    let (loc_x,loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, loc.1, loc.2);
    
    // Set all location pixels to be red // r,g,b
    //image.get_pixel_mut(loc_x, loc_y).data = [255, 0, 0];
    //circle_it(&mut image, loc_x, loc_y, [255, 0, 0]);
    draw_hollow_circle_mut(&mut image, (loc_x as i32, loc_y as i32), 10 /*radius*/, Rgb([255, 0, 0]));
    
    // Also draw an index number
    let font_height = 18.0;
    let font_scale = Scale { x: font_height, y: font_height };
    draw_text_mut(&mut image, Rgb([225, 225, 255]), loc_x as u32, loc_y as u32, font_scale, &font, format!("{}", i).as_str());
  }
  
  for i in 0..path.len() {
    let pt_from = path[i];
    let pt_to =   path[(i+1) % path.len()];
    //println!("pt_from = {}, pt_to = {}", pt_from, pt_to);
    
    let from_loc = locations[pt_from];
    let (from_loc_x,from_loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, from_loc.1, from_loc.2);
    
    let to_loc = locations[pt_to];
    let (pt_to_x,pt_to_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, to_loc.1, to_loc.2);
    //println!("Going from {} to {}", pt_from, pt_to);
    
    draw_line_segment_mut(&mut image,
      (pt_to_x as f32,pt_to_y as f32), // start
      (from_loc_x as f32,from_loc_y as f32), // end
      Rgb([200, 200, 200])
    );
  }

  // does the folder exist?
  let file_parent_dir = std::path::PathBuf::from(file_path.clone());
  let file_parent_dir = file_parent_dir.parent().expect("All image paths should have a parent");
  std::fs::create_dir_all(&file_parent_dir).unwrap_or(());
  
  image.save(file_path).unwrap();
}

fn save_state_image_center<I: Into<String>>(file_path: I, path: &Vec<usize>, locations: &Vec<(usize, fp, fp)>, center: &(fp, fp)) {
  let file_path = file_path.into();
  let (width, height) = (600, 600);
  let mut image = RgbImage::new(width + 5, height + 5); // width, height
  
  let (smallest_x, largest_y, largest_x, smallest_y) = get_point_extents(locations);
  let x_range: fp = largest_x - smallest_x;
  let y_range: fp = largest_y - smallest_y;
  
  let font = Font::try_from_bytes(include_bytes!("../resources/NotoSans-Bold.ttf")).unwrap();

  for i in 0..locations.len() {
    let loc = locations[i];
    let (loc_x,loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, loc.1, loc.2);
    
    // Set all location pixels to be red // r,g,b
    //image.get_pixel_mut(loc_x, loc_y).data = [255, 0, 0];
    //circle_it(&mut image, loc_x, loc_y, [255, 0, 0]);
    draw_hollow_circle_mut(&mut image, (loc_x as i32, loc_y as i32), 10 /*radius*/, Rgb([255, 0, 0]));
    
    // Also draw an index number
    let font_height = 14.0;
    let font_scale = Scale { x: font_height, y: font_height };
    draw_text_mut(&mut image, Rgb([225, 225, 255]), loc_x as u32, loc_y as u32, font_scale, &font, format!("{}", i).as_str());
  }
  
  for i in 0..path.len() {
    let pt_from = path[i];
    let pt_to =   path[(i+1) % path.len()];
    //println!("pt_from = {}, pt_to = {}", pt_from, pt_to);
    
    let from_loc = locations[pt_from];
    let (from_loc_x,from_loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, from_loc.1, from_loc.2);
    
    let to_loc = locations[pt_to];
    let (pt_to_x,pt_to_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, to_loc.1, to_loc.2);
    //println!("Going from {} to {}", pt_from, pt_to);
    
    draw_line_segment_mut(&mut image,
      (pt_to_x as f32,pt_to_y as f32), // start
      (from_loc_x as f32,from_loc_y as f32), // end
      Rgb([200, 200, 200])
    );
  }
  
  // center is green cross
  let (center_img_x, center_img_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, center.0, center.1);
  draw_cross_mut(&mut image, Rgb([0, 255, 0]), center_img_x as i32, center_img_y as i32);
  
  image.save(file_path).unwrap();
}

fn scale_xy(img_w: u32, img_h: u32, path_w: u32, path_h: u32, path_x_smallest: fp, path_y_smallest: fp, given_x: fp, given_y: fp) -> (u32, u32) {
  let mut img_x = (given_x - path_x_smallest) * ((img_w as fp / path_w as fp) as fp);
  let mut img_y = (given_y - path_y_smallest) * ((img_h as fp / path_h as fp) as fp);
  if img_x < 5.0 {
    img_x = 5.0;
  }
  if img_x > (img_w-5) as fp {
    img_x = (img_w-5) as fp;
  }
  if img_y < 5.0 {
    img_y = 5.0;
  }
  if img_y > (img_h-5) as fp {
    img_y = (img_h-5) as fp;
  }
  return (img_x as u32, img_y as u32);
}

// returns smallestX, largestY, largestX, smallestY
fn get_point_extents(locations: &Vec<(usize, fp, fp)>) -> (fp, fp, fp, fp) {
  let mut smallest_x = fp::INFINITY;
  let mut largest_y = fp::NEG_INFINITY;
  let mut largest_x = fp::NEG_INFINITY;
  let mut smallest_y = fp::INFINITY;
  for loc in locations {
    let x = loc.1;
    let y = loc.2;
    if x < smallest_x {
      smallest_x = x;
    }
    if x > largest_x {
      largest_x = x;
    }
    if y < smallest_y {
      smallest_y = y;
    }
    if y > largest_y {
      largest_y = y;
    }
  }
  return (smallest_x, largest_y, largest_x, smallest_y);
}

fn compute_weight_coords(node_coordinates: &Vec<(usize, fp, fp)>) -> Vec<Vec<fp>> {
  // Compute 2x matrix of edge weights (assumes 2d euclidian geometry)
  let mut weights: Vec<Vec<fp>> = Vec::with_capacity(node_coordinates.len());
  {
    for row_r in node_coordinates {
      let mut row_weight_v: Vec<fp> = Vec::with_capacity(node_coordinates.len());
      for col_r in node_coordinates {
        let weight: fp = (
          (row_r.1 - col_r.1).powf(2.0) + // x1 + x2 squared
          (row_r.2 - col_r.2).powf(2.0)   // y1 + y2 squared
        ).sqrt();
        
        row_weight_v.push(weight);
      }
      weights.push(row_weight_v);
    }
  }
  return weights;
}

fn selective(min_cities_to_ignore: usize, max_cities_to_test: usize, thread_pool: &ThreadPool) {
  println!("Performing selective failure from {} points to {} points...", min_cities_to_ignore, max_cities_to_test);
  // Bounding box for all points
  //let x_min_bound: fp = 0.0;
  //let x_max_bound: fp = 15.0;
  //let y_min_bound: fp = 0.0;
  //let y_max_bound: fp = 15.0;
  
  //let bound_granularity = 0.25; // step size with which to make grid points after failure
  
  let x_min: fp = 5.0;
  let x_max: fp = 10.0;
  let y_min: fp = 5.0;
  let y_max: fp = 10.0;
  
  let mut rng = rand::thread_rng();
  let mut node_coordinates: Vec<(usize, fp, fp)> = vec![];
  
  // Just add 3 to begin with
  for i in 0..3 {
    let new_r_city = (
      i,
      rng.gen_range(x_min, x_max),
      rng.gen_range(y_min, y_max),
    );
    node_coordinates.push(new_r_city);
  }

  // Don't bother solving short tours which are highly likely to be correctly solved by jeff_algo
  // We can always manually configure this parameter down if this discoveres a horrible failure and
  // we want to find the first city where stuff blows up.
  for city_num in 3..min_cities_to_ignore {
    let new_r_city = (
      city_num,
      rng.gen_range(x_min, x_max),
      rng.gen_range(y_min, y_max),
    );
    node_coordinates.push(new_r_city);
  }
  
  // If we hit 11 cities without a failure we'll recurse and start from min_cities_to_ignore again.
  for city_num in min_cities_to_ignore..max_cities_to_test {
    let new_r_city = (
      city_num,
      rng.gen_range(x_min, x_max),
      rng.gen_range(y_min, y_max),
    );
    node_coordinates.push(new_r_city); // we can pop() if we fail
    
    let city_weights = compute_weight_coords(&node_coordinates);
    
    let jeff_sol = jeff_algo::solve(&node_coordinates, &city_weights, None);
    let brute_sol = brute_algo::solve(&node_coordinates, &city_weights, None, thread_pool);
    
    let jeff_sol_len = compute_dist(&city_weights, &jeff_sol);
    let brute_sol_len = compute_dist(&city_weights, &brute_sol);
    let distance_diff = jeff_sol_len - brute_sol_len;
    
    if distance_diff.abs() > fp_epsilon && !is_identical_path(&jeff_sol, &brute_sol) { // account for floating point errors
      println!("We have broken jeff_algo at {} points!", city_num+1);
      // we have added a city which breaks things!
      node_coordinates.pop();
      let city_weights = compute_weight_coords(&node_coordinates);
      
      // Now we have a city right before our failure.
      
      // Save the correct solution
      brute_algo::solve_all(&node_coordinates, &city_weights, Some("./views/selective/".to_string()), thread_pool);
      jeff_algo::solve(&node_coordinates, &city_weights, Some("./views/selective/".to_string()));
      
      // compute a 2d matrix of points and plot blue if they result in correct, red if they do not.
      // perform_matrix_image_gen("./views/selective-map.png", node_coordinates, city_weights, );
      
      // UPDATE: this is now done by spray() as a separate step.
      
      return;
    }
  }
  
  println!("Failed to break after {}, resetting...", max_cities_to_test);
  selective(min_cities_to_ignore, max_cities_to_test, thread_pool);
  
}

fn is_identical_path(path_a: &[usize], path_b: &[usize]) -> bool {
  if path_a.len() != path_b.len() {
    return false; // duh
  }

  let mut smallest_usize_in_a = usize::MAX;
  let mut smallest_usize_idx_in_a = 0;
  for i in 0..path_a.len() {
    if path_a[i] < smallest_usize_in_a {
      smallest_usize_in_a = path_a[i];
      smallest_usize_idx_in_a = i;
    }
  }

  let mut smallest_usize_idx_in_b = 0;
  for i in 0..path_b.len() {
    if path_b[i] == smallest_usize_in_a {
      smallest_usize_idx_in_b = i;
      break;
    }
  }

  // Both lists now have a begin index at their smallest value (assume 0)
  // we walk them & compare values; if any are not equal then these have
  // different orders!
  for i in 0..path_a.len() {
    if path_a[(i+smallest_usize_idx_in_a) % path_a.len()] != path_b[(i+smallest_usize_idx_in_b) % path_b.len()] {
      return false; // Not identical b/c values differ!
    }
  }

  return true; // identical b/c all path_a[i+] == path_b[i+]
}

fn get_env_or_random_node_coordinates(n: usize, env_var_name: &str, x_min: fp, x_max: fp, y_min: fp, y_max: fp) -> Vec<(usize, fp, fp)> {
  let mut rng = rand::thread_rng();
  let mut node_coordinates: Vec<(usize, fp, fp)> = vec![];
  // Create random set of points OR parse from env var
  match env::var(env_var_name) {
    Ok(initial_coords_s) => {
      // initial_coords_s == "5.12,6.8 4.8,4.9, 1.2,1.3"
      let pairs: Vec<&str> = initial_coords_s.split(" ").collect();
      for i in 0..n {
        let x_and_y_s: Vec<&str> = pairs[i].split(",").collect();
        let x: fp = x_and_y_s[0].parse().expect("TSP_INITIAL_COORDS did not contain a number");
        let y: fp = x_and_y_s[1].parse().expect("TSP_INITIAL_COORDS did not contain a number");
        let new_r_city = (
          i, x, y
        );
        node_coordinates.push(new_r_city);
      }
    }
    Err(_) => {
      for i in 0..n {
        let new_r_city = (
          i,
          rng.gen_range(x_min, x_max),
          rng.gen_range(y_min, y_max),
        );
        node_coordinates.push(new_r_city);
      }
    }
  }
  return node_coordinates;
}

fn spray(n: usize, mut bound_granularity: fp, thread_pool: &ThreadPool) {
  println!("Spraying {} cities...", n);

  if bound_granularity < 0.025 {
    println!("Resetting {} to 0.025 because that's the size of a single pixel...", bound_granularity);
    bound_granularity = 0.025;
  }
  let bound_granularity = bound_granularity;
  
  // Bounding box for all points
  let x_min_bound: fp = 0.0;
  let x_max_bound: fp = 15.0;
  let y_min_bound: fp = 0.0;
  let y_max_bound: fp = 15.0;
  
  let x_min: fp = 3.0;
  let x_max: fp = 12.0;
  let y_min: fp = 3.0;
  let y_max: fp = 12.0;
  
  let node_coordinates: Vec<(usize, fp, fp)> = get_env_or_random_node_coordinates(n, "TSP_INITIAL_COORDS", x_min, x_max, y_min, y_max);
  println!("Initial node_coordinates={:?}", &node_coordinates);
  
  // Generate partial image
  let file_path = "views/spray.png";
  let (width, height) = (900, 900);
  let mut image = RgbImage::new(width + 15, height + 15); // width, height
  
  let (smallest_x, largest_y, largest_x, smallest_y) = (x_min_bound, y_max_bound, x_max_bound, y_min_bound);
  let x_range: fp = largest_x - smallest_x;
  let y_range: fp = largest_y - smallest_y;
  
  // Use jalgo to compute the first N-1 insertions...
  let city_weights = compute_weight_coords(&node_coordinates);
  let first_ordered_visits = jeff_algo::solve(&node_coordinates, &city_weights, None);

  let brute_sol = brute_algo::solve(&node_coordinates, &city_weights, None, thread_pool);
  // If jeff disagrees w/ brute, the rest of the loop does not make sense!
  let first_ordered_visits_len = compute_dist(&city_weights, &first_ordered_visits);
  let brute_sol_len = compute_dist(&city_weights, &brute_sol);
  let distance_diff = first_ordered_visits_len - brute_sol_len;
  if distance_diff.abs() > fp_epsilon && !is_identical_path(&first_ordered_visits, &brute_sol) {
    println!("Refusing to spray; jeff_sol={:?} ({}) and brute_sol={:?} ({}) are already broken!",
      first_ordered_visits, first_ordered_visits_len, brute_sol, brute_sol_len
    );
    return;
  }

  // Now test a grid of points every bound_granularity units,
  // computing the ideal and jalgo. When the two do not match, make a dot on
  // the spray image we generate.
  
  let mut num_failures = 0;
  
  let mut point_y = y_min_bound;
  loop {
    if point_y > y_max_bound {
      break;
    }
    
    let mut point_x = x_min_bound;
    loop {
      if point_x > x_max_bound {
        break;
      }
      
      let mut node_coordinates = node_coordinates.clone(); // Prevent us from mutating the initial set of points
      node_coordinates.push(
        (node_coordinates.len(), point_x, point_y)
      );
      // Now add (point_x, point_y) and see if it breaks jalgo
      
      let city_weights = compute_weight_coords(&node_coordinates);
      
      //let jeff_sol = jeff_algo::solve(&node_coordinates, &city_weights, None);
      //println!("=============");
      //let jeff_sol = jeff_algo::next_step(&first_ordered_visits, &node_coordinates, &city_weights, &None);
      let jeff_sol = jeff_algo::solve(&node_coordinates, &city_weights, None);
      //println!("jeff_sol={:?}", &jeff_sol);
      
      let brute_sol = brute_algo::solve(&node_coordinates, &city_weights, None, thread_pool);
      
      let jeff_sol_len = compute_dist(&city_weights, &jeff_sol);
      let brute_sol_len = compute_dist(&city_weights, &brute_sol);
      let distance_diff = jeff_sol_len - brute_sol_len;
      //println!("jeff_sol_len={}   brute_sol_len={}  distance_diff={}", jeff_sol_len, brute_sol_len, distance_diff);
      
      let loc = (point_x, point_y);
      let (loc_x,loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, loc.0, loc.1);
      
      if distance_diff.abs() > fp_epsilon && !is_identical_path(&jeff_sol, &brute_sol) {
        // jalgo broke, paint red pixel
        *image.get_pixel_mut(loc_x, loc_y) = Rgb([255, 0, 0]);
        {
          *image.get_pixel_mut(loc_x+1, loc_y) = Rgb([255, 0, 0]);
          *image.get_pixel_mut(loc_x+1, loc_y+1) = Rgb([255, 0, 0]);
          *image.get_pixel_mut(loc_x, loc_y+1) = Rgb([255, 0, 0]);
        }
        num_failures += 1;
        // Also save a copy of the state in views/spray-jalgo*
        // BUT only if bound_granularity > 0.1 as a performance improvement to high-res sprays
        if bound_granularity >= 0.2 {
          let prefix_dir = format!("./views/spray-jalgo-f{:03}", num_failures);
          
          // Debugging jeff_algo::next_step(&first_ordered_visits, &node_coordinates, &city_weights, &Some(format!("{}-jeff-next_step", prefix_dir.clone() ) ));
          //jeff_algo::solve(&node_coordinates, &city_weights, Some(prefix_dir.clone()));
          
          //brute_algo::solve(&node_coordinates, &city_weights, Some(prefix_dir.clone()));
          // Also dump brute_algo solutions for node_coordinates N-1, n-2, etc... until 3

          for i in 3..(node_coordinates.len()+1) {
            let mut delta_node_coords = vec![];
            for j in 0..i {
              delta_node_coords.push( node_coordinates[j] );
            }
            let city_weights = compute_weight_coords(&delta_node_coords);
            jeff_algo::solve(&delta_node_coords, &city_weights, Some(prefix_dir.clone()));
            brute_algo::solve_all(&delta_node_coords, &city_weights, Some(prefix_dir.clone()), thread_pool);
          }
          
        }
      }
      else {
        // jalgo got it correct, paint green
        *image.get_pixel_mut(loc_x, loc_y) = Rgb([0, 255, 0]);
      }
      
      point_x += bound_granularity;
    }
    
    point_y += bound_granularity;
  }

  let font = Font::try_from_bytes(include_bytes!("../resources/NotoSans-Bold.ttf")).unwrap();  
  
  for i in 0..node_coordinates.len() {
    let loc = node_coordinates[i];
    let (loc_x,loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, loc.1, loc.2);
    
    // Set all location pixels to be red // r,g,b
    //image.get_pixel_mut(loc_x, loc_y).data = [255, 0, 0];
    //circle_it(&mut image, loc_x, loc_y, [255, 0, 0]);
    draw_hollow_circle_mut(&mut image, (loc_x as i32, loc_y as i32), 10 /*radius*/, Rgb([255, 0, 0]));
    
    // Also draw an index number
    
    let font_height = 18.0;
    let font_scale = Scale { x: font_height, y: font_height };
    draw_text_mut(&mut image, Rgb([225, 225, 255]), loc_x as u32, loc_y as u32, font_scale, &font, format!("{}", i).as_str());
  }

  // Finally write image to views/spray.png
  if let Err(e) = image.save(file_path) {
    println!("Please create the directory ./views/ before running tests!");
  }
  
  println!("{} failures", num_failures);
  
}

fn pattern_scan(n: usize, bound_granularity: fp, file_path: &str, thread_pool: &ThreadPool) {
  // Bounding box for all points
  let x_min_bound: fp = 0.0;
  let x_max_bound: fp = 15.0;
  let y_min_bound: fp = 0.0;
  let y_max_bound: fp = 15.0;
  
  let x_min: fp = 3.0;
  let x_max: fp = 12.0;
  let y_min: fp = 3.0;
  let y_max: fp = 12.0;

  let node_coordinates: Vec<(usize, fp, fp)> = get_env_or_random_node_coordinates(n, "TSP_INITIAL_COORDS", x_min, x_max, y_min, y_max);
  pattern_scan_coords(n, bound_granularity, file_path, node_coordinates, thread_pool);
}

fn pattern_scan_coords(n: usize, mut bound_granularity: fp, file_path: &str, node_coordinates: Vec<(usize, fp, fp)>, thread_pool: &ThreadPool) {
  println!("Pattern scanning {} cities...", n);
  if bound_granularity < 0.010 {
    println!("Resetting {} to 0.010 because that's the size of a single pixel...", bound_granularity);
    bound_granularity = 0.010;
  }
  let bound_granularity = bound_granularity;
  
  // Bounding box for all points
  let x_min_bound: fp = 0.0;
  let x_max_bound: fp = 15.0;
  let y_min_bound: fp = 0.0;
  let y_max_bound: fp = 15.0;
  
  let x_min: fp = 3.0;
  let x_max: fp = 12.0;
  let y_min: fp = 3.0;
  let y_max: fp = 12.0;
  
  println!("Initial node_coordinates={:?}", &node_coordinates);

  // Generate partial image
  // let file_path = "views/pattern-scan.png";
  let (width, height) = (900, 900);
  let mut image = RgbImage::new(width + 15, height + 15); // width, height
  
  let (smallest_x, largest_y, largest_x, smallest_y) = (x_min_bound, y_max_bound, x_max_bound, y_min_bound);
  let x_range: fp = largest_x - smallest_x;
  let y_range: fp = largest_y - smallest_y;
  
  let city_weights = compute_weight_coords(&node_coordinates);

  let mut unique_solution_spaces_points: HashMap<(u8, u8, u8), Vec<(fp, fp)>> = HashMap::new();

  let mut point_y = y_min_bound;
  loop {
    if point_y > y_max_bound {
      break;
    }
    
    let mut point_x = x_min_bound;
    loop {
      if point_x > x_max_bound {
        break;
      }
      
      let mut node_coordinates = node_coordinates.clone(); // Prevent us from mutating the initial set of points
      node_coordinates.push(
        (node_coordinates.len(), point_x, point_y)
      );
      // Now add (point_x, point_y) and see if it breaks jalgo
      
      let city_weights = compute_weight_coords(&node_coordinates);
      
      let brute_sol = brute_algo::solve_all(&node_coordinates, &city_weights, None, thread_pool);
      let num_sols: i32 = brute_sol.len() as i32;
      let rand_idx: i32 = rand::thread_rng().gen_range(0, num_sols);
      let brute_sol: Vec<usize> = brute_sol[ rand_idx as usize ].clone(); // Vec<CityNum>
      
      let loc = (point_x, point_y);
      let (loc_x,loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, loc.0, loc.1);
      
      // Paint according to brute_sol order
      let (r, g, b) = path_to_rgb(&brute_sol, &city_weights);

      let rgb_key = (r, g, b);
      if !unique_solution_spaces_points.contains_key(&rgb_key) {
        unique_solution_spaces_points.insert(rgb_key, vec![]);
      }
      unique_solution_spaces_points.get_mut(&rgb_key).map(|key_vec| { key_vec.push( (point_x, point_y) ); });
      
      // println!("RGB of {:?} is {}, {}, {}", brute_sol, r, g, b);

      //*image.get_pixel_mut(loc_x, loc_y) = Rgb([r, g, b]);

      // Larger 4x4 dots
      *image.get_pixel_mut(loc_x, loc_y) = Rgb([r, g, b]);
      {
        *image.get_pixel_mut(loc_x+1, loc_y) = Rgb([r, g, b]);
        *image.get_pixel_mut(loc_x+1, loc_y+1) = Rgb([r, g, b]);
        *image.get_pixel_mut(loc_x, loc_y+1) = Rgb([r, g, b]);
      }
      
      point_x += bound_granularity;
    }
    
    point_y += bound_granularity;
  }

  let font = Font::try_from_bytes(include_bytes!("../resources/NotoSans-Bold.ttf")).unwrap();  
  
  for i in 0..node_coordinates.len() {
    let loc = node_coordinates[i];
    let (loc_x,loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, loc.1, loc.2);
    
    // Set all location pixels to be red // r,g,b
    //image.get_pixel_mut(loc_x, loc_y).data = [255, 0, 0];
    //circle_it(&mut image, loc_x, loc_y, [255, 0, 0]);
    draw_hollow_circle_mut(&mut image, (loc_x as i32, loc_y as i32), 10 /*radius*/, Rgb([255, 0, 0]));
    
    // Also draw an index number
    
    let font_height = 18.0;
    let font_scale = Scale { x: font_height, y: font_height };
    draw_text_mut(&mut image, Rgb([225, 225, 255]), loc_x as u32, loc_y as u32, font_scale, &font, format!("{}", i).as_str());
  }

  // Get average of all points over unique_solution_spaces_points
  // and draw / log brute path for the average point of a shared collection of solutions
  let file_path_name = std::path::Path::new(file_path).file_name().unwrap();
  let file_path_name = &file_path_name.to_str().unwrap();
  let file_path_name = file_path_name.replace(".png", "").replace(".jpg", "");

  for (rgb_key, inserted_points) in unique_solution_spaces_points.iter() {
    let mut sum_x = 0.0;
    let mut sum_y = 0.0;
    for (x, y) in inserted_points.iter() {
      sum_x += x;
      sum_y += y;
    }
    let avg_x = sum_x / (inserted_points.len() as fp);
    let avg_y = sum_y / (inserted_points.len() as fp);
    
    // Draw text
    let (loc_x,loc_y) = scale_xy(width, height, x_range as u32, y_range as u32, smallest_x, smallest_y, avg_x, avg_y);
    let rgb_text = format!("{:02x}{:02x}{:02x}", rgb_key.0, rgb_key.1, rgb_key.2 );
    let font_height = 18.0;
    let font_scale = Scale { x: font_height, y: font_height };
    // Apply a random += y delta for the label to prevent labels from overlapping in outputs
    let loc_y = loc_y + ( rand::thread_rng().gen_range(-32.0, 32.0) as fp );
    draw_text_mut(&mut image, Rgb([225, 225, 255]), loc_x as u32, loc_y as u32, font_scale, &font, rgb_text.as_str());

    let mut node_coordinates = node_coordinates.clone(); // Prevent us from mutating the initial set of points
    node_coordinates.push(
      (node_coordinates.len(), avg_x, avg_y)
    );

    // Also compute brute force for avg_x, avg_y and store under views/pattern-scan-{rgb_text}-center/

    let parent_prefix_dir = format!("views/{}", file_path_name);
    std::fs::create_dir_all(&parent_prefix_dir).unwrap_or(());
    
    let prefix_dir = format!("views/{}/{}-center", file_path_name, rgb_text);
    for i in 3..(node_coordinates.len()+1) {
      let mut delta_node_coords = vec![];
      for j in 0..i {
        delta_node_coords.push( node_coordinates[j] );
      }
      let city_weights = compute_weight_coords(&delta_node_coords);
      brute_algo::solve_all(&delta_node_coords, &city_weights, Some(prefix_dir.clone()), thread_pool);
    }

  }



  // Finally write image to views/pattern_scan.png
  if let Err(e) = image.save(file_path) {
    println!("Please create the directory ./views/ before running tests!");
  }

  println!("{} unique solutions found + plotted!", unique_solution_spaces_points.len());

}

fn multi_pattern_scan(n: usize, bound_granularity: fp, num_multi_steps_to_scan: usize, thread_pool: &ThreadPool) {
  println!("Muti-pattern scanning {} cities...", n);
  
  // Bounding box for all points
  let x_min_bound: fp = 0.0;
  let x_max_bound: fp = 15.0;
  let y_min_bound: fp = 0.0;
  let y_max_bound: fp = 15.0;
  
  let x_min: fp = 3.0;
  let x_max: fp = 12.0;
  let y_min: fp = 3.0;
  let y_max: fp = 12.0;

  let node_coordinates_a: Vec<(usize, fp, fp)> = get_env_or_random_node_coordinates(n, "TSP_INITIAL_COORDS", x_min, x_max, y_min, y_max);
  println!("Initial node_coordinates_a={:?}", &node_coordinates_a);

  let node_coordinates_b: Vec<(usize, fp, fp)> = get_env_or_random_node_coordinates(n, "TSP_ENDING_COORDS", x_min, x_max, y_min, y_max);
  println!("Initial node_coordinates_b={:?}", &node_coordinates_b);

  let mut output_scan_files = vec![];
  for multi_step_i in 0..=num_multi_steps_to_scan {
    let converged_cities = converge_coordinates(&node_coordinates_a, &node_coordinates_b, multi_step_i, num_multi_steps_to_scan);
    let output_multiscan_file_path = format!("views/multi-pattern-scan-{:03}.png", multi_step_i);
    pattern_scan_coords(n, bound_granularity, &output_multiscan_file_path, converged_cities, thread_pool);
    output_scan_files.push(output_multiscan_file_path);
  }

  let gif_output_file = "views/multi-pattern-scan.gif";

  let images = engiffen::load_images(&output_scan_files);
  if let Ok(gif_data) = engiffen::engiffen(&images, 5 /*fps*/, engiffen::Quantizer::Naive ) {
    if let Ok(mut output_f) = File::create(gif_output_file) {
      if let Err(e) = gif_data.write(&mut output_f) {
        eprintln!("Error writing to {}: {:?}", gif_output_file, e);
      }
    }
  }
  println!("See {}", gif_output_file);

}

fn converge_coordinates(a: &Vec<(usize, fp, fp)>, b: &Vec<(usize, fp, fp)>, step_num: usize, total_steps: usize) -> Vec<(usize, fp, fp)> {
  if a.len() != b.len() {
    panic!("a.len() = {} and b.len() = {}", a.len(), b.len());
  }
  let mut converged = vec![];
  for i in 0..a.len() {
    converged.push(
      converge_coords(a[i], b[i], step_num, total_steps)
    );
  }
  converged
}

fn converge_coords(a: (usize, fp, fp), b: (usize, fp, fp), step_num: usize, total_steps: usize) -> (usize, fp, fp) {
  let a_weight = (total_steps - step_num) as fp / total_steps as fp;
  let b_weight = step_num as fp / total_steps as fp;
  #[allow(non_upper_case_globals)]
  const rounded_decimals: fp = 1000.0;
  (
    a.0,
    (((a.1 * a_weight) + (b.1 * b_weight)) * rounded_decimals).round() / rounded_decimals,
    (((a.2 * a_weight) + (b.2 * b_weight)) * rounded_decimals).round() / rounded_decimals,
  )
}


static PATH_TO_RGB_CACHE: Lazy<Mutex<HashMap<usize, (u8, u8, u8) >>> = Lazy::new(|| {
  Mutex::new( HashMap::new() )
});

fn path_to_rgb(path: &[usize], city_weights: &Vec<Vec<fp>>) -> (u8, u8, u8) {
  
  // Iterate city from zero_i to end_i, calculating a hash in both directions.
  
  let mut zero_i = 0;
  for i in 0..path.len() {
    if path[i] == 0 {
      zero_i = i;
    }
  }
  let zero_i = zero_i;

  let end_i = (zero_i + (path.len() - 1) ) % path.len();
  
  let mut left_i = zero_i;
  let mut right_i = end_i;
  let mut left_hash = std::collections::hash_map::DefaultHasher::default();
  let mut right_hash = std::collections::hash_map::DefaultHasher::default();
  
  path[zero_i].hash(&mut right_hash); // right hash must visit 0 first to prevent off-by-one during flipped path comparisons.

  loop {
    // Hash the value into S, we only care about value and aligned ordering.
    path[left_i].hash(&mut left_hash);
    path[right_i].hash(&mut right_hash);

    left_i = (left_i+1) % path.len(); // increment w/ wrap
    right_i = (right_i+(path.len()-1)) % path.len(); // decrement w/ wrap

    if left_i == end_i { // if this is ever NOT the terminating case I'm fine w/ a loud process hang
      if right_i != zero_i {
        panic!("Invariant violation, expected when left_i={} == end_i that right_i ({}) == {}", left_i, right_i, zero_i);
      }
      path[left_i].hash(&mut left_hash);
      //path[right_i].hash(&mut right_hash); // cannot hash here, see instruction directly above loop{}
      break;
    }
  }
  let left_hash_u64 = left_hash.finish() as usize;
  let right_hash_u64 = right_hash.finish() as usize;

  // If hash_u64 is in cache, re-use same color.
  // Else generate something random but "nice" and store in cache.

  let mut path_to_rgb_cache_ref = PATH_TO_RGB_CACHE.lock().unwrap();
  if let Some(colors) = path_to_rgb_cache_ref.get(&left_hash_u64) {
    return *colors;
  }
  else if let Some(colors) = path_to_rgb_cache_ref.get(&right_hash_u64) {
    return *colors;
  }
  else {
    let r = rand::thread_rng().gen_range(40, 220) as u8;
    let g = rand::thread_rng().gen_range(40, 220) as u8;
    let b = rand::thread_rng().gen_range(40, 220) as u8;

    // for all future hash_u64s in THIS process, re-use same color.
    // Not deterministic across machines.
    path_to_rgb_cache_ref.insert(left_hash_u64, (r, g, b));
    path_to_rgb_cache_ref.insert(right_hash_u64, (r, g, b));

    // Debugging
    //println!("Unique color ({:02x}{:02x}{:02x}) allocated for path = {:?} hashes=({}, {})", r, g, b, path, left_hash_u64, right_hash_u64);

    return (r, g, b);
  }
}



